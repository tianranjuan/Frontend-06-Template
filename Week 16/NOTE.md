# 轮播组件 | 手势动画应用

> 在组件化的设计中，一些诸如 state 等概念不是一定要提出来编程一些编程范式的，只要是 state 这个概念存在即可，不必强求一些形式上的表现。

**bug 修复**

关于之前视频中出现右侧划太多次会出现负数 index 的解决更好的办法是通过先对 children.length 取模，这样就可以将负数先转换成整数，再进行计算就不会出现问题了。

# 轮播组件 | 为组件添加更多属性（一）

**状态的设计**

可以使用 Symbol 来将所有的内部状态和属性保护起来，然后如果有需要特殊需要暴露给外部调用者的属性可以再将 Symbol 给 export 出去。

# 14 - 16 周組件化总结

组件是一种用于专门描述 UI 界面上功能的抽象模型，在一般情况下包含了：生命周期，属性，状态，树状结构等几个特点。

**状态的设计**

1. 应该只能由组件内部进行控制，保证状态的一致性；
2. 组件内部的控制状态改变的条件应该是用户的输入，而不是组件的调用者。

在设计状态时，应对状态进行足够的保护，否则任谁都可以修改的状态是灾难性的，同时状态应该尽可能的简单，太过复杂的状态管理成本太高。

状态的定义可以通过 Symbol 来进行私有化的处理。


**属性的设计**

属性其实也可以细分为：组件内使用的，组件外使用的，组件内外都可以使用的。

**模型的抽象**

组件所使用的模型应该由某一使用场景或业务出发，将可能的情况进行高层次的抽象，最后暴露出统一的接口，这样更有利于组件的维护和组件的使用。

比较典型的抽象模型就是15周的手势库，手势库通过将移动端和pc端的事件在内部抽象为统一的start、move、end行为来实现兼容和屏蔽掉底层的差异，让手势的监听变得更加容易。

而15周的timeline则是通过将元素属性和动画帧关联起来作为时间轴上的一个点来进行抽象，最后通过一个虚拟的时间线来进行管理，将动画的繁琐操作统统屏蔽掉同时让动画也变得更加可控。

**封闭性**

一个良好的组件应该是完备的，除去必要输入外，内部的运转机制应不受外部因素影响。


**树状结构**

在设计上有两个方向，即子组件的两大类设计方向：

1. content 类型，属于在组件的设计阶段就设计好的，最多控制显隐，但是不能改变实际子组件数量，比如按钮组件，其行为和样式基本固定，只需要填充内容即可，在生成时大部分内容都是由组件内部自己控制，然后针对性的填充内容。
2. template 类型，设计时只是一个占位性质，具体由多少个子组件最终由数据来进行控制，比如 list 的子组件 list-item 只是一个占位，具体产生多少个取决于传入的数据数量来生成。

