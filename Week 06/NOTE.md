# 12.2 JS 语言通识 | 泛用语言分类方法

## 乔姆斯基谱系

乔姆斯基体系是由诺·乔姆斯基于 1956 年提出的，是刻画形式文法表达能力的一个分类谱系。

包含 4 个层次：

0-型文法（无限制文法或短语结构文法）包括所有的文法。该类型的文法能够产生所有可被图灵机识别的语言。可被图灵机识别的语言是指能够使图灵机停机的字串，这类语言又被称为递归可枚举语言。注意递归可枚举语言与递归语言的区别，后者是前者的一个真子集，是能够被一个总停机的图灵机判定的语言。

简单的说就是只要能被图灵机顺利读完，并保证了输出的就 ok。

1-型文法（上下文相关文法）生成上下文相关语言。这种文法的产生式规则取如 αAβ -> αγβ 一样的形式。这里的 A 是非终结符号，而 α, β 和 γ 是包含非终结符号与终结符号的字串；α, β 可以是空串，但 γ 必须不能是空串；这种文法也可以包含规则 S->ε ，但此时文法的任何产生式规则都不能在右侧包含 S 。这种文法规定的语言可以被线性有界非确定图灵机接受。

简单的说就是 A 需要通过 α, β 来决定，并且同时决定了 A 是否会被 γ 进行替换。

2-型文法生成上下文无关语言。这种文法的产生式规则取如 A -> γ 一样的形式。这里的 A 是非终结符号，γ 是包含非终结符号与终结符号的字串。这种文法规定的语言可以被非确定下推自动机接受。上下文无关语言为大多数程序设计语言的语法提供了理论基础。

简单的说就是 A 总是会被 γ 所替代，而不需要考虑 A 的具体上下文含义。

3-型文法（正规文法）生成正规语言。这种文法要求产生式的左侧只能包含一个非终结符号，产生式的右侧只能是空串、一个终结符号或者一个非终结符号后随一个终结符号；如果所有产生式的右侧都不含初始符号 S ，规则 S -> ε 也允许出现。这种文法规定的语言可以被有限状态自动机接受，也可以通过正则表达式来获得。正规语言通常用来定义检索模式或者程序设计语言中的词法结构。

简单的理解就是可以被正则完全验出来的语法就是 ok。

文法之间存在包含关系，3 型文法一定也是 2 型文法，2 型文法也一定是 1 型文法，但是反之则不一定成立。

### 一些名词含义

**图灵机**

指一个抽象的机器，有一条无限长的纸带，纸带分为一个一个的格子，图灵机会逐个扫描纸带的格子，然后转换为自己内部的状态，并进行移动。

**图灵机停机**

如果图灵机最后停机并进入了某个特定的终结状态，那么就说明图灵机接受该字符串。

**递归可枚举语言**

能被图灵机接受的字符串组成的语言称为递归可枚举语言。

**递归语言**

如果一个图灵机对于任何串都停机，则这个语言称为递归语言。

# 12.2 JS 语言通识 | 什么是产生式

## 巴科斯范式（BNF）

这个在分析四则运算的课程有过一个大概的了解了，这里就补充一下规则。

巴科斯范式 以美国人巴科斯(Backus)和丹麦人诺尔(Naur)的名字命名的一种形式化的语法表示方法，用来描述语法的一种形式体系，是一种典型的元语言。又称巴科斯-诺尔形式(Backus-Naur form)。它不仅能严格地表示语法规则，而且所描述的语法是与上下文无关的。

语法：

1. 在双引号中的字("word")代表着这些字符本身；
2. 在双引号外的字（有可能有下划线）代表着语法部分
3. 尖括号( < > )内包含的为必选项
4. 方括号( [ ] )内包含的为可选项
5. 大括号( { } )内包含的为可重复 0 至无数次的项
6. 竖线( | )表示在其左右两边任选一项，相当于"OR"的意思
7. ::= 是“被定义为”的意思
8. 加号( + )表示至少出现一次
9. 星号( \* )表示重复多次

# 12.2 JS 语言通识 | 深入理解产生式

js 总体上是上下文无关的定义，特殊语法是上下文相关的定义，如：

```js

{
    get a { // 上下文相关的
        return 1;
    },
    get:2 // 上下文无关的
}

```

例子中，get 后面有 a 的时候是一个关键字，所以是根据上下文来确定的，是上下文相关的，后面没有 a 时，是对象的一个 key 值，所以这时是一个上下文无关的。

**如何判别产生式属于什么文法**

1. 一些有限语意的 DSL 应该都属于 3 型文法（正则文法），通常此类语法都是使用有限状态机即可完实现；
2. 一些基础的关键字定义等，属于 2 型文法，如加法产生式，变量声明等；
3. 一些右结合的，逻辑控制语句等就属于 1 型文法，如 goto，if。\*\*（乘方）等；
4. 能让计算机读出来，并有相应响应的就是 0 型文法。

# 12.2 JS 语言通识 | 现代语言的分类

**按用途分类**

数据描述语言：

1. sql
2. html
3. markdown
4. css
5. xml
6. yml

编程语言：

1. java
2. javascript
3. c#
4. c++
5. c
6. lisp
7. kotlin
8. go
9. dart
10. rust
11. haskell
12. python
13. php
14. lua

**按表达法师分类**

声明式语言：

1. sql
2. html
3. markdown
4. css
5. xml
6. yml
7. lisp
8. haskell

命令式语言：

1. java
2. javascript
3. c#
4. c++
5. c
6. kotlin
7. python
8. rust
9. lua
10. dart

# 12.2 JS 语言通识 | 编程语言的性质

**协变与逆变**

以前在看《effective java》里面介绍泛型时有提到逆变与协变，当时没能理解，现在来看应该的话应该就是：

1. 如果定义的是子类型，调用时可以传入父类型，就是逆变
2. 如果定义的是父类型，调用时可以传入子类型，就是协变

**强类型与弱类型**

以前就是与动态类型与静态类型混淆了

**虚假的强类型与弱类型**

动态类型 = 弱类型
静态类型 = 强类型

**真实的强类型与弱类型**

系统会不会自动的发生类型转换，强类型语言不会自动转类型，需要进行显式的强转，(int)"1"；弱类型语言会隐式自动的进行转换，如 JavaScript 中"=="时产生的各种诡问题。

# 12.2 JS 语言通识 | 一般命令式编程语言的设计方式

一般的语言设计时的 5 个层面：

1. Atom（原子层）：由一些关键字，直接量组成，为语言中的最小单位，如：let string number "123";
2. Expression（表达式层）：由一个或多个关键+一些操作符组成的最小执行单元，如 let a = 1，&，||，!等；
3. Statement（语句层）：由表达式+一些关键字组成的逻辑单元，如 if，while，for 等；
4. Structure（结构层）：由函数、类、命名空间等组成，用于分隔代码，复用代码；
5. Program（程序层）：一些基础设施能力，如包管理，依赖管理等，一些语言设计在语言中，一些语言设计为挂载插件的方式。

一般来说语言设计到第三层（Statement）就已经可以实现图灵完备了，可以进行简单的使用，如果需要支持一定规模的开发的话就不能止步于第三层了，就需要拥有完整的生态才可以了。

# 12.6 JS 类型 | Number

**7 种基本类型**

这里没有算上在途的`BigInt`

1. Number
2. String
3. Boolean
4. Object
5. Null
6. Undefined
7. Symbol

在实际编程开发中常用的应该就只有前 5 种，写一些通用库时会用到 7，6 尽可能的只进行判断，而不应该实际使用赋值给其他变量。

**Null 与 Undefined 的区别**

Null: 有值，只不过是个空值（Null）;

Undefined: 不光是没值，甚至都没有人进行过定义。

一般不推荐将 Undefined 赋值给其他值，只需要检查某一个值是否为 Undefined 就好了，需要置空时，可以使用 Null 进行置空。

**Null 的历史包袱**

由于早期设计时间短的问题，一个著名的设计 bug，对 Null 值使用 typeof 时会返回一个 Object

产生原因：

JS 语言设计中，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“ object ”。

所以判断对象类型时，为了保持正确应该使用 `Object.prototype.toString.call(obj)`的方式进行。

**Symbol**

ES6 新特性，专门用于替代 String 在 Object 中属性名的使用场景。

使用 Symbol 作为 key 值的属性，可以用来模拟私有属性，这样的话只要没有将 Symbol 引用暴露给外界，那么外界就不能直接通过字符串的形式获取到 Symbol 对应的变量。

## Number 是怎么定义的？

**IEEE754 中的定义**

JS 中的 Number 定义时根据 IEEE 754 中双精度浮点数定义的

IEEE 给出的定义是：

$$Value = sign * exponent * fraction$$

其中：

- value：二进制原值
- sign：符号位 取值 0，1,
- exponent：阶码 = 阶码真值 + 127（32 位情况）
- fraction：尾数 = 去除最高位后的小数部分

在 js 中是这么进行实现的：

```
0 |  1 0 0 0 0 0 0 0 0 0 0 | 1 | 0 0 0 0 0 0 ... 0 0 0 0
s |  ---exponent(11bit)--- | h | ----fraction(52bit)----
```

最高位是符号位，后面是 11 的阶码，最后是 52 位尾数，在尾数前有 1 位的隐藏为，后面会说这个是干嘛的。

直接这么看定义有点懵，首先先看下二进制如何标识小数

**二进制如何使用科学计数法标识小数**

公式：
$$a * 2^n$$

其中：

- 指数的基数是 2
- |a| >= 1&& |a| < 2
- n 为正整数

举例:

$$5.75_{10} = 5 + 3/4 = 4 + 1 + 2/4 +1/4  = 2^2 + 2^0 + 2^{-1} + 2^{-2} = 101.11_2 = 1.0111_2 * 2^2$$

对应这个公式重新看浮点数的定义

阶码 对应的是 n
隐藏位对应的是 1.0
尾数对应的是 0.0111

所以

$$1.0111_2 * 2^2 = 隐藏位1.尾数 * 2^{阶码}$$

**为什么要有一个隐藏位？**

因为在二进制的科学计数法中，最高位永远是固定值 1，所以就隐藏掉了，这样的话就可以多出的一位尾数就可以标识更加精确的精度了。

**过程模拟**

存入时：

1. 10 进制 -> 2 进制
2. 2 进制 -> 2 进制科学计数法
3. 存储阶码(2 的几次幂 + 偏移量)，存储尾数（去掉整数部分有效数字 1 后，存入小数部分），存入符号（0 或 1）

取出时：

1. 判断符号位（0 是整数，1 是负数）
2. 获取阶码 - 偏移量
3. 获取尾数 + 1
4. 按顺序组合到一起返回

**一些细节问题**

东西太多，都在参考资料里了，暂时先不展开研究了。

- 为什么存在偏移量？
- 偏移量为什么是 2^(n-1) -1 而不是 2^(n-1)

**总结**

经过上面讨论，可以得知 js 中（或者说 IEEE 中）对浮点数的定义并不是直接存储，而是通过三个部分（包含隐藏位，实际是 4 个部分）分别存储二级制科学计数法中的`有效数字`、`小数部分`、`2的几次幂`来标识的，每次在存储时，会先将 10 进制转换成 2 进制，然后再转换为科学计数法，然后再讲`阶码`、`尾数`、`符号`分别存到对应的内存区域中，当获取该数字时，再通过反向的推导回来。

这个过程中由于涉及到了 10 进制转 2 进制，所以精度问题实质上在创建的时候就已经发生了，而不是仅发生在计算时。

# 12.6 JS 类型 | String

**string 是如何工作的？**

string 由 character 组成，character 有 code point 组成，code point 最后会变成具体的编码，实际例子就是字符串"a",由字符"a"组成，字符"a"在 ASCII 码中码点被定义为 97，码点 97 最后会被编码成 8 位的二进制'0110 0001'存起来。

**常见的字符集**

1. ASCII
2. Unicode
3. GBK
4. GB2312
5. ISO-8859

**Unicode 编码**

UTF8:

1. 默认用 1 个字节表示一个字符
2. 长度可变

**如何实现变长**

UTF8 在编码中文时，会根据规则插入控制位来告诉计算机到底是如何编码的，从而达到变长的效果。

> 因为 UTF8 默认用 1 个字节表示一个字符，所以其实是完全向后兼容 ASCII 的。

## 编码练习

开始没搞懂，后来可算搞明白了

编码区间和格式：
```
编码范围                    编码格式
0000 0000 - 0000 007F  -  0xxxxxxx
0000 0080 - 0000 07FF  -  110xxxxx 10xxxxxx
0000 0800 - 0000 FFFF  -  1110xxxx 10xxxxxx 10xxxxxx
0001 0000 - 0010 FFFF  -  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```
进行编码时要按照对应字符的取值，取出对应的 unicode 码，然后这个码是一个介于 0 - 65535 之间的整数，然后根据这个证书在进行二进制的编码，编码过程：

1. 获取到 unicode 码；
2. 判断位于哪个编码区间，<0x80 则位于 1 个字节的区间，<0x800 则位于 2 个字节的区间，以此类推；
3. 确定编码区间后进行二进制编码
   1. 按照区间模板进行运算，1 个字节的模板：0xxxxxxx，2 个字节的模板：110xxxxx 10xxxxxx，3 个字节的模板：1110xxxx 10xxxxxx 10xxxxxx 以此类推；
   2. 如果是 1 个字节则直接返回就可以了，不需要进行其他操作
   3. 其中用到的技巧
      1. 对于高位的字节使用右移 n 位来获取前几位数，n 是后面字节需要填充的总位数，如 2 个字节模板的后一个字节是 10xxxxxx，需要填充 6 位那么此时就应该右移 6 位，然后与当前字节模板进行或运算；
      2. 对于中间字节则需要使用到与运算来进行计算，首先右移后面需要填充的位数，然后与运算当前字节编码模板中待填充位的反码，如 3 个字节的模板中第 2 个字节是 10xxxxxx， 那么待填充位的反码 00111111，然后再和当前字节模板进行或运算；

```js
// 处理三个字节长度
buffer.push(0xe0 | (charCode >> 12));
buffer.push(0xc0 | ((charCode >> 6) & 0x3f));
buffer.push(0x80 | (charCode & 0x3f));

// 0x3f 是 10xxxxxx中待填充位的反码 00111111 的16进制表示
// 0xe0 是 1110xxxx的16进制表示
// 0x80 是 10xxxxxx的16进制表示
```



# 12.6 JS 类型 | 其他类型

**undefined**

undefined 表示变量没有定义。
undefined 在早起版本中可以进行重新赋值，如今在局部变量中也可以进行重新赋值。

如果想获取一个 undefined 的最佳实践是使用`void 0`，因为 void 是关键字，经过 void 运算后，右边不管是什么都会是 undefined，这样可以避免使用的 undefined 被人为修改过，从而引发 bug。

# 12.6

## 对象 Object

**特性**

1. 任何一个对象都是唯一的，与本身状态无关。
2. 状态一致的对象不见得是同一个对象。
3. 我们使用状态来描述对象。
4. 状态的改变即是行为。

**三要素**

1. 唯一标识
2. 状态
3. 行为

**类的分类流派**

1. 归类：只是提取共性进行抽象，自底向上的抽象，很自然的多继承；
2. 分类：自顶向下的抽象，先有 object，然后再细分类型，所以是单继承的。

js 更接近`分类`思想

**原型模式**

原型模式是通过选择一个基础类，然后通过修改基础类的不同状态，来派生子类的，比如说：

选定了一只鲤鱼作为原型，如果想要一个鲶鱼对象，那么就在鲤鱼的基础上进行修改:"身体光滑","肉食","无鱼鳞"等状态，从而派生出一个鲶鱼对象来。

也就是说仅仅描述自身与原型的区别即可实现派生子类。

原型模式在继承链上一般以`Object prototype`作为最基础的原型来描述，也有语言支持更高级的原型:`nihilo（虚无的）`，在 JavaScript 的设施中就是以 Null 为原型（Object.create(null)）;

> 原型模式也常常用来开发游戏生成多种类的怪物，只需要描述同种类怪物的不同兵种间的差别即可。

**如何抽象出高内聚的对象**

在练习中，成功走到了误区里，设计成了"狗咬人"；这其实是不对的，违背了面向对象的设计理念；
在面向对象设计中，应该要思考问题中的行为到底是什么，这个行为并不是显示中的行为，而是改变对象状态的行为。

也就是说某一个需求或者说动作，它最后的目的是改变谁的状态，练习中是改变人的状态，那么维护这个状态改变的行为的一方就应该是人，是人受到了伤害所以人来改变自身的状态，而不能是狗来维护，因为狗来维护，那么狗要是咬其他动物，甚至说咬玩具这样的需求就没有办法在同一个行为中实现了，最后就会变成"狗咬人"，"狗咬狗"，"狗咬玩具"等等多的方法来维护状态，所以说这样的设计就会丧失高内聚特性，变成耦合在一起了。

当然维护状态也不能是传入一个狗的对象进来，因为这样的话就又是耦合在一起了，因为人受伤的原因会有很多，不仅仅限于被狗咬，还可能被"猫"，"蛇"，"熊"等等动物攻击，所以传入的对象应该是一个更抽象的对象，其中包含了攻击者来源的抽象对象。

所以在日常开发中，要多思考思考对象与对象间关系，不要被字面意思所引导，有时对象间真正的关系可能就像练习中的一样，明明是设计一个"狗咬人"，实际却是如何设计"人被咬"。

# 12.6 JS 对象 | JS 中的对象

在 JavaScript 的运行时中，原生对象的描述很简单，我们只需要关系原型和属性即可。

当当前对象的属性上找不到时，就会去原型对象上找，知道找到目标属性或者是找到了 null 为止，这就是原型链。

**属性**

js 中是使用 key-value 的形式来描述的，其中 key 可以是 symbol 或者 string，string 作为属性名时并不能很好的控制访问权限，只要能写对就一定能调用，而 symbol 由于其特性（一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的）只要不暴露给外界那么外界是无法获取到 symbol 引用的，所以可以很好的实现私有属性。

属性分为：

1. 数据属性
2. 访问器属性

数据属性包含了：

1. 具体的值，也就是 value
2. writeable 是否可写选项， 设置为 false 后，使用.运算符不能修改 value，但是使用 object.defindProperty 还是可以改的
3. enumerable 是否可枚举选项
4. configurable 是否可配置选项，设置为 false 后 上面的几项都无法修改

访问器属性包含了：

1. get
2. set
3. enumerable
4. configurable

一般来说访问器属性描述了行为，数据属性描述了状态，但是如果数据属性存入了函数那么也是有可能描述行为的。

**Host Object**

语言标准中没有定义，可以由宿主环境提供，也就是类似于 Node 使用 V8 提供出来的 IO 能力等，浏览器中的表现为 window，setTimeout 等。

可以实现语言标准没不支持，但是语法上可以支持的一些功能。

# 参考

- [乔姆斯基谱系 | 百度百科](https://baike.baidu.com/item/%E4%B9%94%E5%A7%86%E6%96%AF%E5%9F%BA%E8%B0%B1%E7%B3%BB)
- [typeof null 为什么返回 object?(“typeof null”的历史) | CSDN](https://blog.csdn.net/SDUST_JSJ/article/details/102574663)
- [从科学记数法到浮点数标准 IEEE 754 | 微信公众号](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)
- [IEEE 754 格式是什么? | 知乎](https://www.zhihu.com/question/21711083)
