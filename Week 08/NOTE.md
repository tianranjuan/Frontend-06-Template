# 12.15 浏览器总论 | 浏览器工作原理总论

目标：实现一个 toy-browser

**浏览器的基本流程**

1. url -> http 请求
2. http 响应 -> 解析为 dom
3. 计算 css -> 挂在到 dom 上
4. 计算布局 -> 绘制到 bitmap 上
5. 最终显示

# 12.15 状态机 | 有限状态机

> 有限状态机的重点在机上，而不是状态上。

**什么是有限状态机**

是一种抽象模型，作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件

其特点：

1. 状态总数有限；
2. 在任意时刻，都只处于一种状态下；
3. 某种条件下会从一种状态转变为另一种状态。

常应用于游戏等领域中，如：动画播放和切换，NPC 的 AI 逻辑等。

**理解**

1. 状态机的每一个状态其实都是代表了一个对应的逻辑计算单元，该单元都应具有计算，存储，输出等能力；
2. 状态机的每一个状态应该是输入一致的，字面意思；
3. 状态机的每一个状态应该是一个无副作用的纯函数，如果不是纯函数则状态会受到外界影响，增大出现 bug 的风险。

**状态机的种类**

1. moore 型状态机，状态机的状态切换逻辑是固定的，a -> b -> c，是不受输入和输出控制的。
2. meely 型状态机，状态机的状态切换是由输入决定切换到哪一个状态，a -> b ? c。

**js 中实现状态机（meely 型）**

> 框架思路就是：每个状态函数都会返回下一个状态的函数，一系列返回状态函数的一批状态函数

```js
// 状态函数
function state(input) {
  return nextState; // 返回下一个状态的状态函数
}

// 获取输入
while (input) {
  state = state(input); // 切换状态
}
```

# HTTP 请求 | HTTP 的协议解析

**网络模型**

OSI-7 层模型

1. 应用层 -> 最上层，最贴近用户，为用户最终看到的结果，包含的协议有:HTTP HTTPS 等；
2. 表示层 -> 用于数据的表示和压缩等用途，包含的格式:ASCII、JPEG 等；
3. 会话层 -> 用于建立、管理、终止会话；
4. 传输层 -> 定义传输数据的协议端口号，以及流控和差错校验，包含的协议有:TCP、UDP 等；
5. 网络层 -> 用于网络寻址，实现网络间的路径选择等，包含的协议有: IPV4/IPV6 等；
6. 数据链路层 -> 建立逻辑连接、进行硬件地址寻址、差错校验等功能，将比特组成数据帧，使用 MAC 地址进行介质访问；
7. 物理层 -> 建立、维护、断开物理连接。

TCP/IP-5 层协议

与 OSI-7 层协议基本一致，只不过是将应用层、表示层、会话层都压缩为了应用层。

1. 应用层 -> 最上层，最贴近用户，为用户最终看到的结果，包含的协议有:HTTP HTTPS 等；
2. 传输层 -> 定义传输数据的协议端口号，以及流控和差错校验，包含的协议有:TCP、UDP 等；
3. 网络层 -> 用于网络寻址，实现网络间的路径选择等，包含的协议有: IPV4/IPV6 等；
4. 数据链路层 -> 建立逻辑连接、进行硬件地址寻址、差错校验等功能，将比特组成数据帧，使用 MAC 地址进行介质访问；
5. 物理层 -> 建立、维护、断开物理连接。

当 url 输入后，浏览器便会根据 7 层(5 层)协议，由应用层逐层的下降将请求发送出去，而服务端会从物理层逐层向上进行还原并在处理后发送响应回去。

## TCP 协议

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。

TCP 具有以下的特点：

1. 基于流的传输方式；
2. 面向连接；
3. 可靠的通信方式（也带来了一定的性能损耗）；
4. 通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点。

处理规则：

1. 数据分片，在发送端对用户数据进行分片，在接收端进行重组，由 TCP 确定分片的大小并控制分片和重组；
2. 到达确认，接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；
3. 超时重发，发送方在发送分片时启动超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片；
4. 失序处理，分片失序时，接收端需要对数据重新排序，保证将正确的数据正确的发送给应用层；
5. 重复处理，分片发生重复时，接收端必须要丢弃重复数据；
6. 数据校验，TCP 将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验和有差错，TCP 将丢弃这个分片，并不确认收到此报文段导致对端超时并重发；

三次握手：

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在 socket 编程中，客户端执行 connect()时。将触发三次握手。

1. 第一次握手：客户端发送一个 TCP 的 SYN 标志位置 1 的包指明客户打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里
2. 第二次握手：服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1 同时，将确认序号(Acknowledgement Number)设置为客户的 I S N 加 1 以.即 X+1
3. 第三次握手：客户端再次发送确认包(ACK) SYN 标志位为 0,ACK 标志位为 1.并且把服务器发来 ACK 的序号字段+1,放在确定字段中发送给对方.并且在数据段放写 ISN 的+1

完成三次握手后 TCP 就算是真正链接上了。

HTTP 就是基于 TCP 协议的上层协议，所以刨去报文的格式问题，基本规则也都适用。

# HTTP 请求 | 服务端环境准备

## HTTP

HTTP 是一个应用层文本协议，在万维网的发展过程中扮演了重要角色，HTTP 构建在 TCP 上层它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。

运作方式：

请求-响应必须一一对应，也就是必须要由服务端向客户端发起请求（Request），而服务端也必须要给出响应（Response）

**Request 报文**

```
POST / HTTP/1.1  // 标识行
// 报文头
Host: 127.0.0.1
Content-Type: application/x-www-form-unrlencoded
// 报文头

field1=aaa&field2=x%3D1 // 报文体
```

**标识行**

`POST / HTTP/1.1 `

request-line 行，分为三个部分以空格分割

第一部分`POST`表示请求方法，常用的有：POST、GET、PUT、DELETE、OPTIONS 等

第二部分`/`表示请求路径默认是"/"根目录，在 URL 或 URI 中是端口后面的部分如："http://localhost:8080/user"中的"/user"就是请求路径

第三部分`HTTP/1.1`用于标识使用的协议版本，有 1.0、1.1、2.0 等版本可选值

**报文头**

请求头包含了内容类型，目标地址等信息的定义，使用 K-V 模式进行定义，长度不固定，以空行为标识结束；
服务器端会根据请求头中的信息对报文进行解析，除了协议内必须的报文头外其他的都是可选项，同时只要满足 K-V 格式那么 HTTP 协议是允许用户自定义请求头进行扩展的。

**报文体**

根据`Content-Type`声明的格式，将内容按照格式进行编码。

**常用的 Request Content Type**

1. "application/json" => {"name": "123"}
2. "application/x-www-form-unrlencoded" => name=abc&age=12
3. "multipart/form-data" 上传文件时使用，将表单的数据处理为一条消息，以标签为单元，用分隔符分开，[参考链接](https://www.jianshu.com/p/4db0b0fb9378)

**报文中的换行**

HTTP 中的换行符一律使用`\r\n`来进行定义。

# HTTP 请求 | 实现一个 HTTP 的请求

总结：

1. Content-type 是必要字段，需要有默认值；
2. body 使用 k-v 格式进行定义；
3. 不同的 Content-type 类型，会影响 body 的编码方式；
4. Content-Length 不建议暴露给外部；

# HTTP 请求 | send 函数的编写，了解 response 格式

**Response 报文**

```
HTTP/1.1 200 OK  // 标识行
// 报文头
Content-Type: text/html
Date: 23 Dec 2020 06:12:21 GMT
// 报文头

// 报文体
26 // chunk分割标识
<html><body>Hello world</body></html> // chunk片中的部分报文体
0 // chunk分割标识
// 报文体
```

**标识行**

status line，由三部分组成，由空格分割

第一部分`HTTP/1.1` 表明 HTTP 的协议版本

第二部分`200` 状态码标识服务器处理请求后的状态

常见状态码：

1. 2\*\* -> 成功
2. 3\*\* -> 多与资源状态，需要进一步处理，设计到资源的重定向、已缓存等
   1. 301 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替
   2. 302 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI
   3. 304 资源已缓存
   4. 305 必须使用代理访问
3. 4\*\* -> 客户端错误，请求包含语法错误或无法完成请求
   1. 400 客户端请求的语法错误，服务器无法理解
   2. 401 缺少用户认证
   3. 403 服务端拒绝处理
   4. 404 找不到服务器
4. 5\*\* -> 服务器端处理错误
   1. 500 服务器内部错误，无法完成请求
   2. 502 无效请求
   3. 503 服务器繁忙
   4. 505 不支持的 HTTP 协议版本

第三部分`OK`状态的字符串描述文本

**chunk body 解析**

chunk body 被服务器进行了分片，其规则是以一个 16 进制的数字单独占一行，代表了当前片的字节长度，紧接着下一行跟着当前片的内容，当读取到 0 时则代表已经没有片可读，所有的 body 都已经被解析。

思路：

1. 先读取 16 进制的片长度，并记录下来
2. 换行后读取片内容
3. 依次将读取到的字符添加到数组中，并将片长度-1
4. 当读到回车(\r)时，如果长度为 0 则代表已经读完当前片了，状态机切换到读取新片的状态
5. 当读到取到的片长度为 0 时则代表 body 全部解析完毕，设置读取状态的旗子为 true 并退出解析
