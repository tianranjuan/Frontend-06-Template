# 12.8 JS 表达式 | 运算符和表达式

## 表达式

**member expression**

优先级最高表达式，也是最低级的语法结构（低级表示在语法树会优先的构建，处于树的最深层）

1. a.b
2. a[b] // 与·运算符一样，但是支持了运行时的变量调用
3. foo`string`
4. super.b // 这两个 super 和正常变量的调用优先级没区别，只是调用的是父类的，只有在 class 的构造函数里能用
5. spuer['b']
6. new.target
7. new Foo()

这个`new.target`没见过，看 MDN 是这么描述的：

> new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。

看例子应该是会指向当前对象的实例的引用上。

**new expression**

稍低于 member 表达式

1. new Foo

**new Foo() 与 new Foo 的区别**

这个应该是因为`()`可以省略的问题引申出来的问题:

```js
new a()();

new new a()();
```

上面的代码中，第一种比较好理解，先 new 了 a 对象，然后再调用，而第二种由于括号可以省略的写法则产生了歧义，如果没有这个优先级的区别，就会出现两种情况`new [new a]()`(这种看着就比较奇怪)和`new [new a()]`，这就不好搞了，所以出了这么个优先级的规定来加以区分吧。

**reference 类型**

也是一种基本类型，不过并不对开发者开放，属于标准中的类型，而非语言中的类型。

感觉视频里老师没有展开讲只是简单的带了一下，查了查资料，觉得应该就是运行时记录对象信息的一个内置记录设施，就像 java 为了实现反射，运行时要时刻记录对象状态信息的一个玩意。

Reference 的结构可以理解为一个没有原型的对象，他包括了三个属性：

1. base // 指向某一个对象，最顶层的全局变量会指向运行环境如：window
2. name // 对象的 key 值，如果是定义一个属性的话，就会是属性名
3. strict // 是否开启严格模式

产生 Reference 的条件简单记忆就是声明变量和使用“`.`”运算法调用变量时会产生，但是如果经过了“,”运算符的话则不会产生 Reference，具体条件可以查看参考资料，不展开记录了。

**call expression**

优先级低于前面，而且在 call 表达式后面的 member 表达式会跟着降级为 call expression。

1. foo()
2. super()
3. foo()['b']
4. foo().b
5. foo()`abc`

> 语法结构的表达情况会多于运算符优先级的表达情况。

**left handside & right handside**

左值表达式和右值表达式

只有左值表达式才有资格在" = "的左边：

```js
a.b = c; // ok的
a + b = c; // 不ok的， a + b不属于左值表达式， 没有资格在 = 左边
```

> js 中(或者说大部分语言中)，没有严格规定什么是右值表达式，只要是非左值的其实就都是右值表达式；同时左值表达式是右值表达式的子集，左值一定是右值，但反之不成立。

**update expression**

1. a++
2. a--
3. ++a
4. --a

**unary**
单目运算符

1. delete // 后面必须跟一个引用类型才能生效
2. void
3. typeof
4. - a // 数字不会改变值， 如果是字符串会发生类型转换
5. - a
6. ~ a // 整数按位取反，不是整数会转成整数
7. !a
8. await // 情况比较复杂，会影响到更大的语法结构，和其他的单目要区别开

**exponental**

乘方运算符，唯一一个右结合的运算符，右结合即有限和右边进行运算

在语法解析上会比较难处理

1. \*\*

```js
// 3 ** 2 ** 3 会按下面的顺序执行
3 ** (2 ** 3);
```

**其他的运算符**

这里是一些优先级更低，但是语法结构更高级的运算符。

1. 加减乘除取余：就是加减乘除和取余，之前的四则运算部分已经分析过了；
2. 位运算： >> << >>>， 右移，左移，带符号右移
3. 关系运算符： < > >= <= instanceof in
4. 相等运算符： == === != !==，老生常谈不多说了，其中涉及的类型转换也很复杂，印象中有 10 来条规则
5. 经典位运算： & ^ |，按位与 异或 按位或，c/c++、java 等语言的底层库中比较常见，js 中还没见到太多的应用
6. 逻辑运算符： && ||，短路逻辑比较好用
7. 三目运算符： exp ? exp1 : exp2 同样有短路原则，但是好像语言间实现不一样，有的不带短路，需要注意，点名 c，但是 c++好像就已经支持短路逻辑了，幸好

# 12.10 JS 表达式 | 类型转换

发生类型转换时，大部分情况都会转换成 Number 类型，位移运算时不但要转换成 Number 还要再转成 Int 类型。

**各类型转换**

1. ""是可以转换成 false 的但是在==时逻辑不太一样；
2. true 转换为 Number 时会变成 1（所有非 0Number 会转成 true，但是反过来都是 1）；
3. false 会转成 0；
4. undefined 转换为 Number 是 NaN，但是 Null 转换为 Number 却是 0；
5. undefined 和 Null 不能转换为 Object；
6. object 转换 Number 会调用 valueOf；
7. object 转 string 会调用 valueOf 和 toString 两个函数；
8. 任何的 object 都会转换成 true，所以空对象也是 true；
9. symbol 不能转成任何类型（除装箱为 object 外）；
10. 任何类型都不能转换为 undefined、null、symbol；
11. boolean、undefined、null 转换为 stirng 时就是加了个引号。

**拆箱**

拆箱就是把 object 变成一个普通类型的过程就是拆箱。

js 进行拆箱时，起主要因素的是 toPrimitive、valueOf、toString 三个函数，其中如果定义了 Symbol.toPrimitive 时会忽略掉其他两个函数。

在决定调用 valueOf、toString 的优先级时会根据不同的运算符会调用不同的顺序，加法时会有限调用 valueOf, 当对象作为属性名时，则会有限的调用 toString，且不会调用 valueOf

```js
var o = {
  toString() {
    return 1;
  },
  valueOf() {
    return 2;
  },
  [Symbol.toPrimitive]() {
    return 3;
  },
};

// 注释掉Symbol.toPrimitive后会打印: -> x2

// 注释掉valueOf和Symbol.toPrimitive后会打印: -> x1

// 全部注释掉用会打印: -> x[object object]
console.log("x" + o);

let x = {};

x[o] = 1;

// 存在Symbol.toPrimitive时打印: -> {3:1}
// 注释掉Symbol.toPrimitive时打印: -> {1:1}
// 注释掉toString时打印: -> {[object object]: 1}
console.log(x);
```

**toString**

每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。

可以自定义一个方法，来取代默认的 toString() 方法。该 toString() 方法不能传入参数，并且必须返回一个字符串。自定义的 toString() 方法可以是任何我们需要的值，但如果它附带有关对象的信息，它将变得非常有用。

通常检测对象类型时也会使用 toString 这样判断更准确。

**valueOf**
JavaScript 调用 valueOf 方法将对象转换为原始值。你很少需要自己调用 valueOf 方法；当遇到要预期的原始值的对象时，JavaScript 会自动调用它。

默认情况下，valueOf 方法由 Object 后面的每个对象继承。 每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值，则 valueOf 将返回对象本身。

JavaScript 的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的 valueOf()方法的返回值和返回值类型均可能不同。

不同类型对象的 valueOf()方法的返回值：

1. Array -> 返回数组对象本身。
2. Boolean -> 布尔值。
3. Date -> 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。
4. Function -> 函数本身。
5. Number -> 数字值。
6. Object -> 对象本身。这是默认情况。因为可以覆盖 toString
7. String -> 字符串值。
8. Math 和 Error 对象没有 valueOf 方法。

**Symbol.toPrimitive**

Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。

在 Symbol.toPrimitive 属性(用作函数值)的帮助下，一个对象可被转换为原始值。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 "number"、"string" 和 "default" 中的任意一个。

**拆箱的总结**

当运算会是数字间进行时（如位运算），就一定会先调 valueOf 函数，而一定会用到字符串的场景时（如被用作对象的 key 值）一定会调用 toString，而如果存在 Symbol.toPrimitive 时就会有限调用 Symbol.toPrimitive。

**装箱**

装箱就是把普通类型包装为 object 表示的过程，很多语言中装箱和拆箱都是隐式进行的。

Object 为除了 undefined 和 null 两种基础类型外的 Number，String，Boolean，Symbol 四种类型都提供了包装类型。

经常使用的 Number、String 等构造器可以直接调用也可以使用 new 关键字创建，直接调用时会返回一个值，而使用 new 关键字时会返回一个对象。

symbol 没有办法直接使用 new 关键字，所以需要特殊的代码来实现装箱：

```js
new Object(Symbol("a")); // 装箱后 Symbol{Symbol("a")}
```

当使用 member（.或[]）进行访问时，如果左边得到了一个基础类型，那么 js 此时会自动装箱，非常的方便。

**误区**

装箱后的对象是真的一个对象，而使用构造器或者字面量的类型是一个基础类型的值，他们是不一样的，这里的区别可以使用 typeof 来验证：

```js
let a = new Number(2);
let b = Number(2);
let c = 2;

console.log("typeof a :=>", typeof a); // Number对象类型
console.log("typeof b :=>", typeof b); // 基础类型 number

console.log("a === b ? :=>", a === b); // false
console.log("a == b ? :=>", a == b); // true 这里进行了自动拆箱
console.log("b === c ? :=>", b === c); // true 因为都是基础类型值
```

同时发现这样也会带来一个 bug 如果一个函数接收参数被拎不清的传入了包装类型，那么在使用 "==="判断是会出现反直觉的 bug

```js
// 期望中a,b都是基础类型
function equals(a, b) {
  return a === b; // 如果此时a或b中有包装类型传入则会返回false,如 a:1, b:Number{1} => false
}
```

# 12.12 JS 语句 | 运行时相关概念

1. 简单语句
2. 复杂语句
3. 声明

**completion record**

用于表示一个语句执行完之后的结果，在《重学前端》的`JavaScript执行（四）：try里面放return，finally还会执行吗？`中有详细的解释，不多做记录了。

**target**

给语句添加标签的语法，常用在多层 for 循环的控制时，但是不太可读，且使用不当出问题相当难排查，一般不推荐用。

# 12.12 JS 语句 | 简单语句和复合语句

## 简单语句

指语句中不会包含其他语句的语句。

包含：

1. 表达式语句 -> i = 1；
2. 空语句 -> 单独一个分号；
3. debugger 语句 -> debugger；
4. return 语句 -> return；
5. throw 语句 -> throw Error()；
6. continue 语句 -> continue；
7. break 语句 -> break。

break 和 continue 可以配合上节课的标签语法来实现代码的逻辑控制，但还是不推荐用。

## 复杂语句

1. 块语句 -> {} 重要的基础设施，让语言支持了多条语句组合的能力，提供了语句形成的树状结构的可能；
2. if 语句
3. switch 语句 -> 在 js 中效率并没有比 if-else 高，所以不需要强制 if 替换为 switch，看习惯即可
4. 迭代器语句
5. with 语句 -> 绑定一个对象并产生一个作用域，在这个作用域里将对象展开到 this，虽然看起来方便，但是很多不符合直觉的地方，所以也是不推荐使用的特性；
6. label 语句 -> 太花里胡哨，让代码可读性和可维护性下降很多；
7. try-catch 语句

**细节**

for 循环在使用 let 进行声明迭代变量时，会在循环内，`{}`外产生一个独立的作用域，用来存储 let 的变量，让`{}`内可以正常访问到迭代变量而不是抛出异常。这个点在讨论 let 到底有没有变量提升的时候经常拿出来说，关于这个的讨论单独写了笔记，这里引用下[关于变量提升](./关于变量提升.md)

# 12.12 JS 语句 | 声明

课程内的声明指的是："凡是对后续语句产生作用的语句都是声明"。所以可能会与 js 标准中的定义不太一样。

1. 函数声明 function
2. 迭代器函数声明 function \*
3. 异步函数声明 async function
4. 异步迭代器函数声明 async function \*
5. 变量声明 val
6. 类声明 class
7. 词法声明 const / let

**作用域范围**

1-5 只认函数体的作用范围，永远会被当做是函数体内的第一行处理（变量提升机制）；
6-7 存在暂时性死区机制，但是也会被进行预处理（有人也称为提升），声明前调用会抛错；

**重点**

老师的观点印证了我之前的关于变量提升的思考，所有的声明都会被预处理，只是 class、const、let 存在了暂时性死区（处于待评估状态），如果在声明语句执行前调用会被解释器识别到状态并抛错。

以后和人对线底气更足了的说。(雾

**作用域**

1-5 的作用域前面已经说过了是只认函数体的，所以不论写在函数体的哪里最终都会提升到函数体的顶部；
而 6-7 则是只作用域当前声明语句的外层 block 语句（即最近的一组{}里），就算预处理也只会提升到这个 block 语句的头部而不是最外层函数体的头部，这是和之前 1-5 的区别。

**最佳实践**

由于使用 let 和 const 后在一个大一点的函数中对于变量的复用和重复声明变的不太方便，所以可以通过 block 语句把代码括起来进行分块，这样就可以隔离开块与块之间的作用域了，非常的方便和清晰。

# 12.13 JS 结构化 | 宏任务和微任务

js 执行粒度（运行时）：

1. 宏任务
2. 微任务
3. 函数调用
4. 语句/声明
5. 表达式
6. 变量/直接量

**宏任务和微任务**

一言以蔽之："宏任务就是指交宿主交给给引擎去执行的任务，微任务就是引擎内部细分后执行的任务"

> 在 JavaScript 中只有 promise 才能产生微任务，也就是说之前是没有微任务这个概念的；
> 同时 setTimeout 一类由宿主环境提供的异步机制，会产生新的宏任务，所以会在当前宏任务以及包含的微任务执行完毕后，通过 eventloop 机制执行。

\*顺带记录一下虽然 setTimeout 等函数直觉上是计时器到时间后立即出发的，可实际上并不是这样，触发的计时器会加入到 eventloop 队列中等待执行，如果前面的任务执行时间长导致 eventloop 阻塞的话会导致 setTimeout 实际执行时间与预期时间不符的现象。

**宏任务和微任务的产生**

当我们需要运行一段代码时，将这段代码的文本串传给 JavaScript 引擎时，此时就产生了一个宏任务。

在 JavaScript 引擎在执行宏任务的过程中会对代码进行解释，此时就可能会根据语法和语意产生了异步任务，所以此时代码就被分割成了多个异步任务块，这些任务块就是微任务，也叫 job。

**事件循环**

概念来自于 Node.js 中的 libuv，在不同的环境中的描述不太一致，但是东西是一个东西。

事件循环是一个生产者-消费者模型，在内部的不同阶段格子维护了一套任务队列机制，在每次循环时逐个执行掉队列内的任务回调，回调也会产生新的任务，从而不断的循环下去。

宏任务就是直接被事件循环所维护的任务，微任务并不由事件循环直接管理，而是引擎内部的状态变化。

# 12.13 JS 结构化 | JS 函数调用

函数调用最后会形成调用栈，导致例子里说的效果是因为每个执行上下文存的东西都是自身当前环境的，而栈顶（当前执行的函数调用）中所能够访问到的执行上下文中的内容就是所有可访问的内容了，由于栈的结构以及执行上下文是自身维护的，所以最后被压入栈的调用其实访问不到底下的执行上下文的，也就导致了示例中无法访问那些其他 js 文件中变量的问题。

**执行上下文**

7 个组成部分：

1. code evaluation state 用于记录代码执行到哪里了的作用，生效于 async 和 generator
2. function 生效于函数初始化
3. sript or module 脚本或模块上下文
4. generator 用于 generator 的信息记录
5. realm 用于保存所有需要使用的内置对象的区域
6. lexicalEnvironment 执行中所需要访问的所有的变量信息
7. variableEnvironment var 声明的记录（历史遗留包袱）可以处理 eval 中的 var 声明

> eval 中如果出现了 var 可以穿透到外层的函数体顶部

**闭包时如何保存的上下文？**

在创建函数时，会生成一个环境记录对象，这个对象记录了函数声明时的 code 和环境记录，其中环境记录会记录当前环境的变量定义，this 指向等信息，然后当函数被导出或 return 后由于其信息已经记录在 environment record 对象中，在执行时也就出现了闭包的效果。

> environment record 是具有传递性的，当出现多层级嵌套的时候会出现当前 environment record 中包含了上层函数的 environment record 的情况，也就形成了链式结构（作用域链），这一条链上的数据也就都保存下来了。

**Realm**

用于构建一个安全沙箱的 api，可以安全的隔离一些代码，防止其拿到全局对象。

Realm 存着一个新的环境，这个环境中可能和原始环境不一样，所以一些函数和一些内置对象都会有所不同。

具体内容可以在参考一下阮一峰老师的[《ES6 入门》](https://www.bookstack.cn/read/es6-3rd/spilt.8.docs-proposals.md)

# 参考

- [从 this 指向到 reference 类型 | 博客园](https://www.cnblogs.com/fayin/p/11044368.html)
