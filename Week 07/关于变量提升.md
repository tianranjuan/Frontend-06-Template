- [1. 提升](#1-提升)
- [2. 声明还是创建？绑定还是初始化还是赋值？](#2-声明还是创建绑定还是初始化还是赋值)
- [3. 使用 var 声明](#3-使用-var-声明)
- [4. 使用 function 声明](#4-使用-function-声明)
- [5. let 到底存不存在提升](#5-let-到底存不存在提升)
  - [5.1. 假设 let 不存在提升](#51-假设-let-不存在提升)
  - [5.2. 假设 let 存在提升](#52-假设-let-存在提升)
  - [5.3. 暂存死区](#53-暂存死区)
  - [5.4. 关于 const](#54-关于-const)
- [6. 总结](#6-总结)
- [7. 参考](#7-参考)

# 1. 提升

意思指代码在在代码执行前预处理阶段由解释器对代码进行扫描后，对代码进行的优化处理，把以某些特定关键字声明的变量提前放置到作用域顶层提前声明、创建的行为。

# 2. 声明还是创建？绑定还是初始化还是赋值？

首先要统一一下概念的认知

```js
var a; // 声明动作同时创建了一个叫a的变量

var a = undefined; // 初始化a（存在提升时在预处理阶段由解释器进行操作）

a = "value"; // 赋值动作 将value赋值给a

var a = "value"; // var声明并创建了a，后又被赋值了value，进行赋值前a会先被初始化为undefined
```

在这段代码中 `var a`是指使用`var`关键字声明并创建了一个变量`a`, `var a = undefined`是将 a 变量进行初始化,而`a = 'value'`中'value'被赋值给了 a

在统一好了概念后，下面就进入正题

# 3. 使用 var 声明

```js
console.log(a);
var a = 1;
```

这里我们都知道由于变量提升会打印出 undefined，那么是为什么呢？
这里大致可以解释为：

js 解释器在扫描了代码后，把所有以`var`关键字进行生命的变量拿出来放到了作用域的最上面进行`声明`并把变量初始化为默认值 undefined

```js
var a = undefined; // 隐藏的，解释器偷偷做的

console.log(a);
var a = 1;
```

然后顺序执行代码，在执行到 console 时读取 a 并打印 undefined，继续执行到`var a = 1`在将 1 赋值给 a，此时如果在下方再次打印则会正确的打印出 1

```js
var a = undefined; // 隐藏的，解释器偷偷做的

console.log(a); // 打印undefined
var a = 1;
console.log(a); // 打印1
```

好的，我们现在知道了在使用 var 声明变量的时候会被解释器偷偷的把变量放到作用域最顶层进行`声明`和`初始化`，由此导致了变量提升的问题，那么 function 是如何表现的呢？

# 4. 使用 function 声明

也是用一个简单例子来进行说明

```js
fn2();

function fn2() {
  console.log(2);
}
```

运行代码我们会发现函数是可以正常执行的，控制台也符合预期的打印出了 2，那么就可以说明 function 关键在预处理阶段会进行`声明并创建`出 fn2 函数、然后初始化为 undefined，初始化完成后再讲函数体赋值给 fn2 函数。

注意`function`关键字的预处理过程比`var`关键字多出一个初始化后立即赋值的步骤，这是解开问题的关键点。

那么在看完了预处理时的过程后我们加深一下难度看一下 function 和 var 结合时会有怎样的结果

```js
var foo;
function foo() {}
console.log(foo);

//------------------
function foo() {}
var foo;
console.log(foo);
```

还是一段示例，运行这两段代码发现都会打印出`function foo(){}`来，这又是为什么呢？

根据上面的推导我们能知道，`var`关键字比`function`关键字在预处理时少了一个赋值的过程，那么解答起来就容易的多了，由于两个变量都叫做`foo`，所以会存在覆盖的情况，在解释器将名为 foo 的变量声明完创建完后，此时`foo`到底是谁还没有定论，仅仅是内存中一个名为`foo`的地址而已，而由于`var`关键字没有赋值动作，所以在创建完变量后任务就到此结束了，而`function`关键字是有赋值动作的，所以在创建完变量后会尝试将函数`foo`的函数体赋值给名为`foo`的变量，正是多了这一步才让变量`foo`在最后被赋值为了`function foo(){}`，此时变量也就确定为就是函数`foo`了，所以也就不难理解为什么我们打印出来也就是函数体`function foo(){}`了

# 5. let 到底存不存在提升

说了这么多，最后来说一下到底 let 存不存在提升的问题，这个问题在一些群里也看到过讨论，也没有什么定论，所以下面是一个我个人的理解。

还是上一个示例

```js
let x = "global";
{
  console.log(x); // Uncaught ReferenceError: x is not defined
  let x = 1;
}
```

首先 let 是一个块级作用域，所以简单的理解就是只会存在`{}`，所以此例中 console 的 x 其实值取的`{}`中的 x。

然后我们执行以下代码发现抛出异常`Uncaught ReferenceError: x is not defined`这是一个变量为定义的异常，这里就很有趣了，我们来尝试分析以下：

## 5.1. 假设 let 不存在提升

假设`let`不存在变量提升，那么在预处理阶段应该会直接丢弃不进行处理，那么也就是说在执行到`console`时在`{}`作用域中并不存在一个名为 x 的变量，如果是这种情况按照 js 引擎的工作方式应该会向上找寻作用域链也就是找到`let x = "global";`这个 x，然后打印出`global`才对，但是显然结果并不是这样，那我们换一个假设试试；

## 5.2. 假设 let 存在提升

假设`let`存在变量提升，那么按照上面的推导在预处理阶段会进行`声明`、`创建`、`初始化`、`赋值`等操作，又由于 console 并没有按照作用域链向上层查找，那么在调用 console 时`{}`中的 x 一定是存在的才会停止向上查找，所以可以推导出`let x = 1;`这一句的声明一定被进行了提升，否则不可能让引擎停止向上层查找。

那既然推导出了 let 存在变量提升，那为什么还会报错呢？那就要说一下 let 的特性`暂存死区`了，下面同样是个人的理解。

## 5.3. 暂存死区

> 与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。

通过 MDN 这段解释我们可以知道 let 创建的变量在初始化前是处于一个在当前作用域块顶部的区域中，这个区域就是`暂存死区`，那么这个`暂存死区`为什么就让 let 和 var 产生了不一样的行为呢？

原因就是 let 虽然被提升到了当前作用域块的顶部，但是当预处理机制将其提升完后并没有对其进行初始化，而是将其标记为待评估状态，当调用一个待评估状态的变量时就会抛出 ReferenceError 异常，只有当代码执行到了初始化(赋值)语句进行了初始化后再调用就会返回正常值变成为一个正常的变量。

代码可以理解为：

```js
let x = "global";
{
  let x; // 此时为待评估状态，等待进行初始化，调用会抛出ReferenceError
  console.log(x); // Uncaught ReferenceError: x is not defined
  let x = 1; // 执行到这一行时，对x进行初始化并且值为1此时，状态变为一个正常的变量
}
```

## 5.4. 关于 const

const 与 let 的行为基本保持一致，区别仅在于 const 没有赋值的操作，只有`声明`、`创建`、`初始化`操作且，并不能对其进行再`赋值`。

# 6. 总结

提升的本质在于将`声明`和`创建`的步骤提升了，而关于`初始化`和`赋值`动作则根据不同的关键字有不同的评估手段和行为，所以关于 let/const 能不能提升这个问题，我觉得需要分情况而定：

- 如果提升被定义为是变量的声明被提前，那么 js 中的这些关键字(`var,function,let,const,class,function*`)就都能够提升
- 如果提升定义为完成了初始化后才算提升，那么 `let/const`就是不能提升的。

# 7. 参考

- [1] [我用了两个月的时间才理解 let](https://zhuanlan.zhihu.com/p/28140450)
- [2] [Are variables declared with let or const hoisted?](https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-hoisted)
- [3] [Runtime Semantics: LabelledEvaluation](http://www.ecma-international.org/ecma-262/6.0/#sec-forbodyevaluation)