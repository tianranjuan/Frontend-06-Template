# 排版 | 根据浏览器属性进行排版

**CSS 中的排版技术**

1. 第一代 normal 流，包含了 display、position、float 等属性；
2. 第二代 flex，更加的贴近开发思维，是一种很灵活的布局方式；
3. 第三代 grid，强大的布局，相当的灵活好用；
4. 可能的第四代 houdini 没怎么了解过，找时间了解下。

**排版的知识**

1. 主轴(main axis) 指布局时的主要延伸方向；
2. 交叉轴(corss axis)指与主轴垂直的方向轴；

**抽象的描述排版属性**

当主轴为水平方向时，主轴涉及的属性有：width、x、left、right，交叉轴设计的属性有：height、y、top、bottom；
当主轴为垂直方向时，主轴涉及的属性有：height、y、top、bottom，交叉轴设计的属性有：width、x、left、right；

**原理**

将 css 中的 width、height、x、y、left、top 等属性，用更抽象的主轴、交叉轴来描述，这样就能以实现具体属性名无关的方式来进行排版计算，如：当主轴方向不论为水平还是垂直时，都可以不关心真是计算的是 width 还是 height，抽象后都是主轴空间（main space），这样的抽象对于计算来说可以使用更多的通用公式而无需关注属性名不同等问题带来的心智压力。

**发生时机**

由于 flex 需要知道子元素的排版信息所以同样是发生在 `<end tag>` 时

**小细节**

参与布局计算时，常常会出现根据排版方向对位置进行加法或减法的计算，通常是使用一个 ±1 来改变符号，-1 时很明显的能看出用以，而正 1 时则可以使用+1 来强调其含义。

# 排版 | 收集元素进行

**分行算法**

1. 如果父元素没有设置主轴尺寸那么就是说大小完全由子元素撑开，也就不存在换行了，设置变量 isAutoMainSize 记录状态
2. 使用 flexLine 与 flexLines 来表示行对象和所有行
3. 从 flex item 获取主轴尺寸属性（width/height）保存为 mainSpace（主轴空间）
4. 遍历子元素
   1. 如果某个元素设置了 flex 属性，那么一定能插入到 flexLine 中
   2. 否则进入判断：
      1. 是否设置了 nowrap 并且 是 isAutoMainSize 模式
         1. 如果设置了那么就强制塞到 flexLine 中
         2. 同时计算并记录交叉轴尺寸最大的那个元素
      2. 否则为 wrap 模式
         1. 如果当前元素的尺寸大于主轴尺寸(父元素设置的主轴尺寸)
            1. 强制缩放为主轴尺寸
         2. 如果主轴空间(mainSpace) < 元素尺寸
            1. 保存当前行的剩余主轴空间和剩余交叉轴空间到当前行上
            2. 创建新行并装入当前元素
            3. 重置主轴空间和交叉轴空间
         3. 否则代表当前行能容纳元素，直接填入到当前行中
      3. 最后计算并记录交叉轴尺寸最大的那个元素
      4. 计算主轴剩余空间
   3. 遍历完全部子元素后，也记录下当前行的主轴剩余空间

# 排版 | 计算主轴

**剩余空间计算规则**

1. 如果是不换行 或者 isAutoMainSize 模式
   1. 设置一下交叉轴尺寸：如果父元素没有设置交叉轴尺寸，那么设置当前计算得出的交叉轴尺寸，否则设置父元素的交叉轴尺寸
2. 否则设置交叉轴尺寸为计算得出的交叉轴尺寸
3. 如果当前主轴空间为负数，需要等比压缩（出现此情况的前提是不换行且内容全部子元素在主轴上所占空间大于父元素设置的主轴空间大小）
   1. 计算缩放比例，公式：父元素主轴尺寸 / 父元素主轴尺寸 - 当前剩余的主轴空间（由于为负数，所以其实是在加上当前剩余空间，所以本质是计算实质上需要多少空间才能容纳下全部元素）
   2. 设置变量 currMain 起始位置为 mainBase
   3. 遍历子元素
      1. 如果设置了 flex 元素则设置主轴方向尺寸为 0
      2. 计算缩放后的尺寸，公式：主轴方向尺寸 = 主轴方向尺寸 \* 缩放标量
      3. 设置元素起始位置、结束位置
      4. 更新 currMain 起始位置
4. 否则代表还有剩余空间，遍历所有行，根据 flex 属性值进行等比分配
   1. 设置当前行的主轴剩余空间
   2. 遍历行内子元素，找到所有的设置了 flex 属性的子元素总数
   3. 如果 flex 子元素个数> 0
      1. 遍历行内子元素
      2. 计算元素在主轴方向上的尺寸， 公式： 主轴尺寸 = (剩余空间 / flex 子元素个数) \* 当前元素 flex 属性值
      3. 设置元素起始位置、结束位置
      4. 更新 currMain 起始位置
   4. 否则通过 justify-content 属性来计算分配规则
      1. 如果是 flex-start
         1. currMain = mainBase
         2. 元素间间隔为 0，step = 0;
      2. 如果是 flex-end
         1. currMain = mainSpace \* mainSign + mainBase
         2. 元素间间隔为 0，step = 0;
      3. 如果是 center
         1. currMain = mainSpace / 2 \* mainSign + mainBase;
         2. 元素间间隔为 0，step = 0;
      4. 如果是 space-between
         1. 元素间间隔为元素个数 - 1 step = mainSpace / (items.length -1 ) \* mainSign;
         2. currMain = mainBase;
      5. 如果是 space-around
         1. 元素间间隔为元素个数 step = mainSpace / items.length \* mainSign;
         2. currMain = step / 2 + mainBase;
      6. 最后遍历所有子元素，设置位置信息
         1. 设置元素起始位置、结束位置
         2. 更新 currMain 起始位置

# 排版 | 计算交叉轴

**要点**

1. 每一行的交叉轴尺寸由单行内的最大尺寸元素决定
2. 根据元素上的 flex-align 和 item-align 属性确定元素具体的位置

思路：

1. 声明当交叉轴剩余空间
2. 如果父元素没有声明交叉轴尺寸
   1. 那么就把当交叉轴尺寸设置为 0，然后把父元素的交叉轴尺寸设置为所有行的交叉轴尺寸的和
3. 否则
   1. 设置父元素的交叉轴尺寸为当前交叉轴剩余空间，然后减去所有行的交叉轴尺寸，计算出剩余真实的交叉轴剩余空间
4. 根据属性 flex-wrap 计算出交叉轴的起始点位置
   1. 如果是 wrap-reverse
      1. 那么 crossBase = 父元素尺寸（也就是从底部开始）
   2. 否则为那么 crossBase = 0
5. 根据父元素的 alignContent 属性计算出 crossBase 是否具有偏移量，以及元素间应该有多少间距（规则与主轴计算相似）
6. 遍历所有行
   1. 如果父元素设置了 alignContent 那么就将每一行都拉伸至等宽，否则设置为当前行的交叉轴尺寸
   2. 遍历行中的每一个元素
      1. 按照元素的 alignSelf 或者父元素 alignItems 来计算当前元素的具体位置
   3. 最后计算一下下一行的起始位置 crossBase


# 总结

**从URL到页面的构成是怎样的？**

一个url从地址栏敲下回车后会通过HTTP请求发送到服务端，由服务端解析后，返回对应的响应，这个响应可能是一个HTML页面也可能是一断数据。

**客户端请求HTML页面后是如何展示到浏览器中的？**

HTML的解析：

客户端在拿到了HTML页面后，会对HTML页面进行逐个字符的解析，也就是词法分析，此时会用到状态机来辅助工作，当遇到合法的token时会发射出去将其转变为一个DOM元素记录下来，记录DOM元素时选用了[栈]结构，因为[栈]结构天然的带有父子嵌套关系。

对于文本节点解在解析时会按照单个字符解析，当转换成DOM元素时才会对多个字符合并产生一个统一的Text类型元素。

CSS样式的计算：

在DOM的解析过程中如果遇到了<style>标签、<link>标签内的样式表信息，则会同步的记录下来，在转换成DOM元素时同步进行CSS计算保存在DOM元素上，这其中可能会遇到异步请求的问题，所以当获取到新的样式表时应该引入一个如何重新计算的机制。

如何布局：

在DOM的解析过程如果解析完了某一组标签结构后，就会对其如何布局进行计算，通过布局算法后，DOM上会附加上在浏览器视口中绘制时每个元素的位置信息，常用的布局有：正常流、table、flex、grid等，但无论布局方式如何不同其目的都是为了计算出在绘制时元素的如何定位。

绘制显示：

当HTML页面中全部的字符解析完毕后，我们就同步的获得了一个完整的DOM树，同时DOM树上具有完整的HTML元素信息、CSS样式信息以及布局的位置信息，此时浏览器通过渲染引擎遍历DOM树上的节点按照布局的位置信息和CSS样式生成bitmap展示在窗口中即可。

**flex布局算法的核心思想是什么？**

flex布局算法的核心思想是通过更高层次的抽象屏蔽底层的CSS样式上的尺寸定义，通过主轴和交叉轴来抽象的描述元素的位置信息。